<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2019-07-12">

<title>Marlin Figgins - Chaos: What it is and where to find it</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog/blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications/publications.html"> 
<span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../writing/writing.html"> 
<span class="menu-text">Writing</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../talks.html"> 
<span class="menu-text">Talks</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="dropdown-header">
 <span class="menu-text">Marlin Figgins</span></li>
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Chaos: What it is and where to find it</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">Math</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">July 12, 2019</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-exponential-map" id="toc-the-exponential-map" class="nav-link active" data-scroll-target="#the-exponential-map">The Exponential Map</a></li>
  <li><a href="#logistic-map" id="toc-logistic-map" class="nav-link" data-scroll-target="#logistic-map">Logistic Map</a></li>
  <li><a href="#bifurcations" id="toc-bifurcations" class="nav-link" data-scroll-target="#bifurcations">Bifurcations</a></li>
  <li><a href="#sensitivity-to-initial-conditions" id="toc-sensitivity-to-initial-conditions" class="nav-link" data-scroll-target="#sensitivity-to-initial-conditions">Sensitivity to Initial Conditions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>If we’re interested in taking a first step towards chaos, the usual starting example is the logistic map. A thousand blog posts have been written about this map and chaos in general. Instead of throwing the equation in your face, I’ll try and show this chaos begins to appear in a very simple system. First, let’s start with the simplest possible model for population size. <span class="math inline">\(\newcommand{\abs}[1]{ \left| #1 \right| }\)</span></p>
<section id="the-exponential-map" class="level2">
<h2 class="anchored" data-anchor-id="the-exponential-map">The Exponential Map</h2>
<p>What if every person had <a href="https://www.pewsocialtrends.org/2015/05/07/family-size-among-mothers/">on average</a> 1.2 kids every generation? Starting with <span class="math inline">\(x_0\)</span> people, the new population would be <span class="math inline">\(1.2 x_0\)</span> the next generation. After two generations, it’d be <span class="math inline">\((1.2)^2 x_0\)</span> and it’d continue like this for the following generations. We have some growth every generation and it multiplies our current population over and over again. If we want to be more general about this, we can say that the population has a <em>growth parameter</em> <span class="math inline">\(\lambda\)</span>. Then we’d write our population growth each generation as a function</p>
<p><span class="math display">\[
\begin{equation}
f(x) = \lambda x.
\end{equation}
\]</span></p>
<p>In general, this function is called the <a href="https://en.wikipedia.org/wiki/Exponential_map_(discrete_dynamical_systems)">exponential map</a> and tells us how big the next generation’s population will be given the population grows by a factor of <span class="math inline">\(\lambda\)</span>. If we keep applying it over and over, we can get the population size several generations in the future. Mathematically, we’d write this as a <em>dynamical system</em>. If we have a starting value or <em>/initial condition</em> <span class="math inline">\(x_0\)</span>. Therefore, the population after 1 generation would be <span class="math inline">\(f^1(x_0) = \lambda x_0\)</span>, after two it would be <span class="math inline">\(f^2(x_0) = \lambda^2x_0\)</span>. For simplicity’s sake, we’d say that after <span class="math inline">\(n\)</span> generations the population is</p>
<p><span class="math display">\[
\begin{equation}
f^n(x_0)=\lambda^nx_0.
\end{equation}
\]</span></p>
<p>We can describe the <em>dynamics</em> of the exponential map by looking at all the population values for each generation</p>
<p><span class="math display">\[\begin{equation}
x_0, f^1(x_0), f^2(x_0), f^3(x_0), \dotsc
\end{equation}
\]</span></p>
<p>From this, we can begin to see that the dynamics will depend on the value of <span class="math inline">\(\lambda\)</span> we pick. When dealing with the exponential map, we can have two kinds of outcomes. The population will either die out (<span class="math inline">\(0&lt;\lambda &lt; 1\)</span>) eventually or it will skyrocket and go to infinity (<span class="math inline">\(\lambda &gt;1\)</span>). If <span class="math inline">\(\lambda &lt; 1\)</span>, then <span class="math inline">\(\lambda \cdot \lambda &lt; \lambda \cdot 1\)</span>, so the population shrinks and the population will die out over time. On the other hand, if <span class="math inline">\(\lambda &gt; 1\)</span>, then <span class="math inline">\(\lambda \cdot \lambda &gt; \lambda \cdot 1\)</span> so the population grows and continues to grow every generation.</p>
<p>In the case we were discussing before, <span class="math inline">\(\lambda\)</span> would be 1.2 kids per person. Each generation, the population would steadily increase and after 20 generations, we’d have over 30,00 people. After 100, we’d have nearly 80 billion!</p>
<table class="table">
<thead>
<tr class="header">
<th>Generation:</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Population:</td>
<td>1000</td>
<td>1200</td>
<td>1440</td>
<td>1720</td>
<td>2070</td>
<td>2490</td>
</tr>
</tbody>
</table>
<!-- {% include figure image_path="/assets/images/on-chaos/exp-growth.png" caption="Plotting the exponential map." %} -->
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/exp-growth.png" class="img-fluid figure-img"></p>
<figcaption>Plotting the exponential map.</figcaption>
</figure>
</div>
<p>This isn’t very realistic because it assumes the population can get infinitely large. When it comes to human population, this probably isn’t realistic. Population growth has to begin to slow down at some point. In this case, there must be some limiting factor to our population growth.</p>
<p>Instead of doing this by hand each time, we could also use a compute program to simulate these dynamics. We can use the following code to simulate these dynamics. Here’s an example program I wrote below.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exponential(x_0 <span class="op">=</span> <span class="dv">100</span>, lambd <span class="op">=</span> <span class="dv">1</span>, max_n <span class="op">=</span> <span class="dv">10</span>):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>   x <span class="op">=</span> []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>   x <span class="op">=</span> np.append(x, x_0)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>   <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(max_n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>       x <span class="op">=</span> np.append(x, lambd<span class="op">*</span>x[n])</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>   <span class="cf">return</span> x</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</section>
<section id="logistic-map" class="level2">
<h2 class="anchored" data-anchor-id="logistic-map">Logistic Map</h2>
<p>What happens to our model if we assume that resources are somehow limited? As more people appear, it’ll become harder for everyone to meet their individual needs to survive . In order to model this, we need the population change to depend not only on a growth rate, but also how close we are to some theoretical maximum population size. If we say <span class="math inline">\(x\)</span> is the current fraction of this maximum population size, we might change our growth rate from <span class="math inline">\(\lambda\)</span> to <span class="math inline">\(\lambda (1-x)\)</span> to allow for the growth rate to decrease as the population increases. Therefore, our model would become</p>
<p><span class="math display">\[
\begin{equation}
f(x) = \lambda(1-x) x.
\end{equation}
\]</span></p>
<p>This is called the <a href="https://en.wikipedia.org/wiki/Logistic_map">logistic map.</a> Strictly speaking, it is a family of maps depending on different values of <span class="math inline">\(\lambda\)</span>. In order to see what happens to the population each generation, we want to analyze the dynamics like in the last example. In the last example, we were able to write a formula for the dynamics and saw the population would either blow up to infinity or die out eventually. This time around we can’t easily write an explicit equation for the dynamics. One usual tool in cases like these where we can’t easily write down a solution is simulation. We can rely on code to help us visualize the population dynamics over time. Here’s the program I use to the simulate the logistic map in the figures below.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Logistic Map</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> logistic_map(x_0 <span class="op">=</span> <span class="fl">0.4</span>, lambd <span class="op">=</span> <span class="fl">1.2</span>, max_n <span class="op">=</span> <span class="dv">500</span>):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> []</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> np.append(x, x_0)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(max_n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        x_new <span class="op">=</span> lambd<span class="op">*</span>x[n]<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>x[n])</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> np.append(x, x_new)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span>(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Despite having the tools to simulate this, let’s try to understand this at an intuitive level first since all good code needs a sanity check. We made this model to account for limits on a population and picked a decreasing growth rate, so you might expect that the dynamics will reflect this and keep the population in check. Even though this works on an intuitive level, we should still try and observe it mathematically. Following this intuition, the first thing we should check is whether our population will stabilize as we expect. Much like in the case of the exponential map, this all depends on the value of the growth parameter <span class="math inline">\(\lambda\)</span>.</p>
<p>It’s actually not that hard to prove that there is some point of stability where the population will stay the same from year to year. In mathematical terms, this is called a <a href="https://en.wikipedia.org/wiki/Fixed_point_(mathematics)"><em>fixed point</em></a>. From our point of view, we say the population <span class="math inline">\(x_\star\)</span> is fixed if <span class="math inline">\(f(x_\star) = x_\star\)</span>.</p>
<p><strong>Proposition</strong>: Every continuous function <span class="math inline">\(f\)</span> takes points from <span class="math inline">\([0,1]\)</span> to <span class="math inline">\([0,1]\)</span> has a fixed point.</p>
<p><em>Proof</em>. Let’s define a new function <span class="math inline">\(D(x) = f(x) - x\)</span>. Since <span class="math inline">\(f(0)\)</span> must be in <span class="math inline">\([0,1]\)</span>, it must be greater than or equal to 0. Therefore, we know <span class="math display">\[D(0) = f(0) - 0 \geq 0.\]</span> Similarly, <span class="math inline">\(f(1)\)</span> is in <span class="math inline">\([0,1]\)</span>, so we know that <span class="math inline">\(D(1)&lt;0\)</span>. Since <span class="math inline">\(f\)</span> is continuous, the <a href="https://en.wikipedia.org/wiki/Intermediate_value_theorem">intermediate value theorem</a> guarantees us that there is a fixed point <span class="math inline">\(x_\star\)</span>.</p>
<p>In order for this to hold for the logistic map, we need to make sure that <span class="math inline">\(f(x)\)</span> stays between 0 and 1 which means that <span class="math inline">\(\lambda\)</span> must be between 0 and 4. Under these assumptions, we can solve for our fixed point(s) directly. One obvious fixed point is <span class="math inline">\(x_\star = 0\)</span>, but let’s see if there are any others. If <span class="math inline">\(x_\star\)</span> is a non-zero fixed point of <span class="math inline">\(f(x)\)</span>, then we need <span class="math inline">\(\lambda(1-x)x = x\)</span>. Dividing by <span class="math inline">\(x\)</span>, we get <span class="math inline">\(\lambda(1-x) = 1\)</span>. Multiplying this out, we get <span class="math inline">\(\lambda - 1 = \lambda x\)</span> which gives shows that our equilibrium value must be</p>
<p><span class="math display">\[
\begin{equation}
x_\star = 1 - \frac{1}{\lambda}.
\end{equation}
\]</span></p>
<p>Notice that in order for this fixed point to be greater than 0, we need <span class="math inline">\(\lambda\)</span> to be greater than 1. This makes sense since otherwise we can expect the population to die out like in the exponential case.</p>
<p>We know it’s possible for our population to stabilize, but when will it? We can use the derivative of this function to help us discern whether this point is <em>attracting</em> i.e.&nbsp;whether initial conditions near it will approach this fixed point.</p>
<p><strong>Proposition</strong>: If <span class="math inline">\(x_\star\)</span> is a fixed point and <span class="math inline">\(\abs{ f'(x_\star)} &lt; 1\)</span>, then it is an <a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=4&amp;ved=2ahUKEwiK4sqwjKzjAhWdJTQIHYu1BygQygQwA3oECAEQBg&amp;url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FFixed_point_(mathematics)%23Attractive_fixed_points&amp;usg=AOvVaw1KvK3S6f6Tfh32Z-NGZSmH">attractive fixed point</a>.</p>
<p><em>Proof</em>. In calculus, we learn that the derivative is given by</p>
<p><span class="math display">\[
\begin{equation}
f'(x_\star) = \lim\limits_{n\to \infty} \frac{f(x) -f(x_\star)}{x-x_\star}.
\end{equation}
\]</span></p>
<p>This tells us that in some neighborhood of <span class="math inline">\(x_\star\)</span>, <span class="math inline">\(f\)</span> is a <a href="https://en.wikipedia.org/wiki/Contraction_mapping">contraction</a>. In technical terms, there exists some <span class="math inline">\(\delta &gt; 0\)</span> such that for <span class="math inline">\((x_\star - \delta, x_\star + \delta)\)</span>,</p>
<p><span class="math display">\[
\begin{equation}
\abs{f(x) - f(x_\star)} &lt; \abs{ x-x_{\star}}.
\end{equation}
\]</span></p>
<p>This means that if we pick a initial condition <span class="math inline">\(x_0\)</span> that is close enough to <span class="math inline">\(x_\star\)</span>, then <span class="math inline">\(x_0\)</span> will get closer to <span class="math inline">\(x_star\)</span> after each iteration or generation in our case.</p>
<p>This makes our problem much easier. If we want to find which <span class="math inline">\(\lambda\)</span> values have attracting fixed points, then we just check to see when <span class="math inline">\(\abs{ f'(x_\star)} &lt; 1\)</span>. Taking the derivative of <span class="math inline">\(f\)</span>, we get <span class="math inline">\(f'(x) = \lambda(1-2x)\)</span>. Plugging in our <span class="math inline">\(x_\star\)</span> value, we see that</p>
<p><span class="math display">\[
\begin{equation}
f'\left(1- \frac{1}{\lambda}\right) = \lambda\left( 1 - 2\left(1- \frac{1}{\lambda}\right)\right) = \lambda\left(\frac{2}{\lambda} - 1\right) = 2 - \lambda.
\end{equation}
\]</span></p>
<p>This tells us that the fixed point is attractive for <span class="math inline">\(\lambda\)</span> between 1 and 2 or between 2 and 3. Now that we’ve confirmed the existence of a fixed point and know a bit about the dynamics of this system, let’s do some simulations to see what happens to our populations over several generations.</p>
<!-- {% include figure image_path="/assets/images/on-chaos/time-series-lambda.png" caption="Population dynamics for different growth parameters." %} -->
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/time-series-lambda.png" class="img-fluid figure-img"></p>
<figcaption>Population dynamics for different growth parameters</figcaption>
</figure>
</div>
<p>As expected from the math we did above, <span class="math inline">\(\lambda\)</span> values in <span class="math inline">\((1,2)\)</span> and <span class="math inline">\((2,3)\)</span> approach the fixed point <span class="math inline">\(1 - \frac{1}{\lambda}\)</span>. Relating this back to our original example, this tells us that having limited resources will cause our population to peak and stabilize. We can see this in the plot above, where <span class="math inline">\(\lambda_2 = 1.2\)</span>. Looking into the rest of the cases, we can also notice that for <span class="math inline">\(\lambda &lt; 1\)</span>, the population dies out which makes sense biologically. A population that can’t successfully replenish itself is going to go extinct. What is interesting here are the values of <span class="math inline">\(\lambda\)</span> that are greater than 3. The population appears to be oscillating periodically for <span class="math inline">\(\lambda_4 = 3.2\)</span>, <span class="math inline">\(\lambda_5 = 3.48\)</span>, and possibly for <span class="math inline">\(\lambda = 3.56\)</span> which corresponds to the population constantly overshooting its threshold and falling back down. When we get to even higher <span class="math inline">\(\lambda\)</span> values, these population dynamics seems to fluctuate like crazy, significantly departing from the cases we looked at before.</p>
</section>
<section id="bifurcations" class="level2">
<h2 class="anchored" data-anchor-id="bifurcations">Bifurcations</h2>
<p>Let’s try and visualize this behavior as <span class="math inline">\(\lambda\)</span> changes with a <a href="https://en.wikipedia.org/wiki/Bifurcation_diagram">bifurcation diagram</a>. A bifurcation diagram helps give us an idea about where our system will eventually end up. We take several trajectories for different <span class="math inline">\(\lambda\)</span> values and plot these <span class="math inline">\(\lambda\)</span> values against where the corresponding population ends up going in the long term. This tells us how the <em>asymptotic behavior</em> of our system changes alongside our growth parameter <span class="math inline">\(\lambda\)</span>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">## Values of lambda to sweep over</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>lambda_range <span class="op">=</span> np.linspace(<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1000</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>tail <span class="op">=</span> <span class="dv">200</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>lambd_seq <span class="op">=</span> []</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>eq_seq <span class="op">=</span> []</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Run the model for 1000 generations and take at the last 200 values.</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> lambd <span class="kw">in</span> lambda_range:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    out <span class="op">=</span> logistic_map(lambd <span class="op">=</span> lambd, max_n <span class="op">=</span> <span class="dv">600</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    lambd_seq <span class="op">=</span> np.append(lambd_seq, [lambd]<span class="op">*</span>tail)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    eq_seq <span class="op">=</span> np.append(eq_seq, out[<span class="op">-</span>tail:])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<!-- {% include figure image_path="/assets/images/on-chaos/bifurcation-logistic-labeled.png" caption="Bifurcation diagram of the logistic map." %} -->
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/bifurcation-logistic-labeled.png" class="img-fluid figure-img"></p>
<figcaption>Bifurcation diagram for the logistic map</figcaption>
</figure>
</div>
<p>Notice where the lines for each of our <span class="math inline">\(\lambda\)</span> values intersect. This tells us about the end behavior of the dynamics for that growth parameter value. For example, notice that <span class="math inline">\(\lambda_4\)</span> intersects the curve twice and the population dynamics seem to oscillate with a period of 2. Similarly, <span class="math inline">\(\lambda_5\)</span> intersects 4 times and we see it has period 4. We can use this idea to confirm our earlier suspicion that the dynamics for <span class="math inline">\(\lambda_6 = 3.56\)</span> are periodic. Looking at the bifurcation diagram, the line for <span class="math inline">\(\lambda_6\)</span> appears to intersect 8 times meaning the population dynamics should have period 8. This leaves us to analyze the higher values of <span class="math inline">\(\lambda\)</span>. As you can see, the plot gets messy as <span class="math inline">\(\lambda\)</span> gets higher. Based on what we saw with the previous cases, there are now many, many points that your population dynamics are going to bounce between and everything becomes extremely irregular. This is <em>chaos</em>.</p>
</section>
<section id="sensitivity-to-initial-conditions" class="level2">
<h2 class="anchored" data-anchor-id="sensitivity-to-initial-conditions">Sensitivity to Initial Conditions</h2>
<p>Up until now, our choice in initial conditions didn’t have much of an effect on where our system ended up. We can see this is the case when we’re working with <span class="math inline">\(\lambda\)</span> values less than 3. Once we begin to move our <span class="math inline">\(\lambda\)</span> values above 3, it becomes increasingly important to be precise with our choice of initial conditions <span class="math inline">\(x_0\)</span>. As you can see below, different but very close initial conditions <span class="math inline">\(x_0\)</span> can lead to very different dynamics. This property is called <em>sensitivity to initial conditions</em> and is one of the hallmarks of chaos.</p>
<!-- {% include figure image_path="/assets/images/on-chaos/different-IC-logistic.png" caption= "Various initial conditions for $\lambda =3.95$." %} -->
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/different-IC-logistic.png" class="img-fluid figure-img"></p>
<figcaption>Various initial conditions for <span class="math inline">\(\lambda =3.95\)</span>.</figcaption>
</figure>
</div>
<p>Here, we see that the populations do diverge significantly even if they start close to one another, but this doesn’t give an idea of <em>how quickly</em> this occurs. Let’s take two initial conditions <span class="math inline">\(x_0\)</span> and <span class="math inline">\(x_0'\)</span> see how their populations change across several generations. For simplicity, let’s say that <span class="math inline">\(x_{0} = x_{0}' + \Delta x\)</span>. At each generation, we’ll check to see how different the population levels are and plot this difference. Here’s the program I used to do this.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>max_n <span class="op">=</span> <span class="dv">40</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>x_0 <span class="op">=</span> <span class="fl">0.7</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>power <span class="op">=</span> <span class="op">-</span><span class="dv">10</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>Delta_x <span class="op">=</span> <span class="dv">10</span><span class="op">**</span>(power)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>IC <span class="op">=</span> [x_0, x_0 <span class="op">+</span> Delta_x]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>time <span class="op">=</span>  np.linspace(<span class="dv">1</span>, max_n, max_n)</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>out1 <span class="op">=</span> logistic_map(lambd <span class="op">=</span> <span class="fl">3.95</span>, max_n <span class="op">=</span> max_n, x_0 <span class="op">=</span> IC[<span class="dv">0</span>])</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>out2 <span class="op">=</span> logistic_map(lambd <span class="op">=</span> <span class="fl">3.95</span>, max_n <span class="op">=</span> max_n, x_0 <span class="op">=</span> IC[<span class="dv">1</span>])</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> <span class="bu">abs</span>(out1 <span class="op">-</span> out2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<!-- {% include figure image_path="/assets/images/on-chaos/lyapunov-logistic.png" caption="Population differences for similar initial conditions." %} -->
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/lyapunov-logistic.png" class="img-fluid figure-img"></p>
<figcaption>Population differences for similar initial conditions.</figcaption>
</figure>
</div>
<p>Notice that the difference between the populations appears to grow <em>exponentially</em> in time for a bit. Let’s try to get a measure of how exponential this. If we try to write the distance as <span class="math inline">\(\text{Dist}(t) \approx Ce^{\chi t}\)</span> for some constants <span class="math inline">\(C\)</span> and <span class="math inline">\(\chi\)</span>. Taking the logarithm of this expression, we can see <span class="math display">\[
\begin{equation}
\log(\text{Dist}) \approx \chi t + \log(C).
\end{equation}
\]</span></p>
<p>With it written this way, we see this is equivalent to saying <span class="math inline">\(\log(\text{Dist})\)</span> is approximately linear in time, so we can do a linear regression to estimate the exponential rate <span class="math inline">\(\chi\)</span>.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>plt.rcParams[<span class="st">'figure.figsize'</span>] <span class="op">=</span> [<span class="dv">12</span>, <span class="dv">9</span>]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>chi_estimate, logC, r_value, p_value, std_err <span class="op">=</span> stats.linregress(time,np.log(dist))</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>lin_reg<span class="op">=</span>chi_estimate<span class="op">*</span>time<span class="op">+</span>logC</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<!-- {% include figure image_path="/assets/images/on-chaos/lyapunov-logistic-lin.png" caption="Log population differences with linear regression." %} -->
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="figures/lyapunov-logistic-lin.png" class="img-fluid figure-img"></p>
<figcaption>Log population differences with linear regression.</figcaption>
</figure>
</div>
<p>This leaves us with <span class="math inline">\(\chi \approx 0.566\)</span>. This number <span class="math inline">\(\chi\)</span> is called a <a href="https://en.wikipedia.org/wiki/Lyapunov_exponent">Lyapunov exponent</a>. In more general contexts, it is used to describe how quickly extremely close trajectories diverge from one another.</p>
<p>As of now, we’ve been able to analyze the behavior of the logistic map, which can be used to describe how populations grow in conditions with limited resources. We saw that the growth parameter <span class="math inline">\(\lambda\)</span> of a population determines how it will grow over time and proved that for some <span class="math inline">\(\lambda\)</span> values the population will stabilize at a fixed value. We also showed that some growth parameters cause the population to overshoot and undershoot consistently leading to oscillation and that for even higher values we end up with chaos. We were able to visualize how this occurs. We explored what it meant to be chaotic by describing sensitivity to initial condition and getting a measure of how sensitive a system is. This was an exercise in using math to take a stab a question we might have about the real world. First, we made a crude model of how we think populations should change every generation, then we went down the rabbit hole of analyzing it. On the way, we got to see some very pretty math and make some pretty cool plots.</p>
<p>That being said, this is not the end-all-be-all of chaos. Chaos is everywhere: in population dynamics with the logistic map, in physics with things like the double pendulum, weather as in the Lorenz equations, and often in infectious disease models. They’re so many chaotic systems out in the world, and I’m itching to write some posts about others that I have or will come across. This also won’t be the last we see of the logistic map. I’m hoping to write a post about the Mandelbrot set, where it comes from, a bit on its connection to the logistic map. For now, this has been an introduction to chaos.</p>
<p>From what we’ve seen in this introduction, chaos is not simply something changing without any rhyme or reason. It must be related to an underlying rule or process describing how things change throughout time or space for a system. Chaos is the idea that uncertainty can grow and grow exponentially quickly. Chaos is realizing that knowing where you are now doesn’t always tell you exactly where you have been in the past. It reminds us that starting from similar conditions or backgrounds doesn’t dictate that you’ll end up in the same place as one another. It tells us that all of our possible paths may at first diverge yet still possibly intersect, intertwine, and become parallel in the future. As you continue along in a chaotic system, it feels as though the future is completely unknown with no clarity to be had. This is when we’re meant to realize that the path ahead is still determined by some underlying rule, even if we don’t understand it yet.</p>
<p><em>Until next time,</em></p>
<p><em>Marlin F.</em></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2023, Marlin Figgins</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/marlinfiggins">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/marlinfiggins">
      <i class="bi bi-twitter" role="img">
</i> 
    </a>
  </li>  
    <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/marlin-figgins">
      <i class="bi bi-linkedin" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>